<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アプリケーション中心のインフラストラクチャの採用 1 - ONDEMANDENV.dev</title>
    <link rel="stylesheet" href="../../styles.css">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-HLWV6BZQE1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-HLWV6BZQE1');
    </script>
    
    <style>
        /* Basic article styling */
        main { max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        h1, h2, h3 { color: var(--primary-color); }
        h2 { margin-top: 2rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; }
        h3 { margin-top: 1.5rem; color: var(--secondary-color); }
        p, ul, ol { line-height: 1.7; margin-bottom: 1rem; }
        ul, ol { margin-left: 1.5rem; }
        li { margin-bottom: 0.5rem; }
        pre { background-color: #f0f0f0; padding: 1rem; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
        code { font-family: monospace; font-size: 0.9em; }
        pre > code { background-color: transparent; padding: 0; }
        blockquote { border-left: 4px solid var(--border-color); padding-left: 1rem; margin-left: 0; font-style: italic; color: #555; }

        /* Language switcher styles */
        .language-switcher {
            position: absolute;
            top: 10px;
            right: 20px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 5px;
            display: flex;
            gap: 5px;
        }
        .language-switcher a, .language-switcher span {
            padding: 5px 10px;
            text-decoration: none;
            color: var(--primary-color);
            border-radius: 3px;
            font-size: 0.9em;
        }
        .language-switcher a:hover {
            background-color: #e9ecef;
            color: var(--secondary-color);
        }
        .language-switcher .active {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
<header>
    <nav>
        <div class="logo">ONDEMANDENV.dev</div>
        <ul>
            <li><a href="../../index.html">ホーム</a></li>
            <li><a href="../../concepts.html">コアコンセプト</a></li>
            <li><a href="../../patterns.html">パターンとユースケース</a></li>
            <li><a href="../../documentation.html">ドキュメンテーション</a></li>
            <li><a href="../../articles.html">記事</a></li>
            <li><a href="https://github.com/ondemandenv" target="_blank">GitHub組織</a></li>
            <li><a href="mailto:contacts@ondemandenv.dev">デモのリクエスト</a></li>
        </ul>
        <div class="language-switcher">
            <a href="../../articles/app-centric-infra1.html">EN</a>
            <a href="#" class="active">JA</a>
            <a href="../../zh-TW/articles/app-centric-infra1.html">ZH-TW</a>
        </div>
    </nav>
</header>

<main>
    <h1>クラウドにおけるアプリケーション中心のインフラストラクチャの採用 1</h1>

    <p>クラウドコンピューティングの世界では、インフラストラクチャとアプリケーションの管理は、しばしば2つの哲学の物語でした。一方では、確実性と一貫性に焦点を当てたエンジニアリングの考え方から生まれたAWS CloudFormationのようなツールがあります。CloudFormationは、コードとしてのインフラストラクチャの定義に優れており、予測可能なデプロイメントと自動ロールバックを保証します。他方では、Kubernetesは運用現場から生まれ、動的なコンテナ化されたアプリケーションのためのアドホックな運用と緩和策を強調しています。Kubernetesはコンテナオーケストレーションにおいて比類のないものですが、伝統的にCloudFormationのような広範なインフラストラクチャ管理能力を欠いていました。</p>
    <p>この相違は、ツールチェーンの無秩序な増加、不整合、および運用上の複雑さにつながっています。しかし、「アプリケーション」の定義がより広範囲の密結合リソースを含むように進化するにつれて、新しいパラダイムが出現しています：アプリケーション中心のインフラストラクチャ。AWS Cloud Development Kit (CDK)のようなツールによって可能になるこのアプローチは、インフラストラクチャとランタイム管理を統一し、一貫性、管理性、およびドメイン駆動型の視点をクラウドデプロイメントにもたらすことを目指しています。</p>

    <h2>CloudFormation vs. Kubernetes：実践における2つの哲学</h2>
    <p>アプリケーション中心のインフラストラクチャへの移行を理解するためには、CloudFormationとKubernetesの根本的な違いを理解することが不可欠です。</p>

    <h3>CloudFormation：エンジニアリングの確実性と自動ロールバック</h3>
    <ul>
        <li><strong>焦点：</strong> Infrastructure as Code (IaC)、AWSリソースの宣言的プロビジョニング。</li>
        <li><strong>哲学：</strong> エンジニアリングの確実性、一貫性、予測可能性。</li>
        <li><strong>障害時のロールバック：</strong> スタック操作の自動ロールバック。リソースの作成または更新が失敗した場合、CloudFormationはすべての変更を元に戻し、一貫した状態を保証します。これは「オールオアナッシング」のデプロイメントを強調し、安定性と予測可能性を優先します。</li>
        <li><strong>依存関係管理：</strong> <code>DependsOn</code>を使用した組み込みの宣言的依存関係サポート。CloudFormationはリソースの作成と削除の順序を理解して強制し、複雑なインフラストラクチャデプロイメントを簡素化します。</li>
    </ul>

    <h3>Kubernetes：運用上の柔軟性と回復力</h3>
    <ul>
        <li><strong>焦点：</strong> コンテナオーケストレーション、コンテナ化されたアプリケーションのライフサイクル管理。</li>
        <li><strong>哲学：</strong> 運用上の柔軟性、回復力、動的環境におけるアドホックな緩和策。</li>
        <li><strong>障害時のロールバック：</strong> 一般的な障害に対するデフォルトでの自動ロールバックなし（Deploymentの更新を除く）。Kubernetesは運用管理を優先し、オペレーターが調査して対象を絞った緩和策を適用できるようにします。ロールバックは通常、明示的なアクションです。</li>
        <li><strong>依存関係管理：</strong> 暗黙的でコントローラー駆動型。Kubernetesはエコシステム内の依存関係（例：PodとService）を管理しますが、CloudFormationのような宣言的なインフラストラクチャレベルの依存関係管理を欠いています。</li>
    </ul>
    <p>これらの対照的なアプローチは、それぞれの起源と主要なユースケースを反映しています。CloudFormationは基盤となるインフラストラクチャ用、Kubernetesはアプリケーションランタイム管理用です。</p>

    <h2>現代の「アプリケーション」：境界付けられたコンテキストとしての垂直スライス</h2>
    <blockquote>「従来、クラウドにおける『アプリケーション』は、Kubernetesによってオーケストレーションされたコンテナのセットと見なされていたかもしれません。しかし、現代のアプリケーションはビジネス機能の垂直スライスであり、多くの場合、以下のもので構成されています。
        <ul>
            <li>コンテナ：マイクロサービス、コンテナにパッケージ化されたアプリケーションロジック。</li>
            <li>データベース：RDSのようなマネージドデータベース、またはDynamoDBのようなサーバーレスオプション。</li>
            <li>ストレージ：オブジェクトストレージ（S3バケット）、ブロックストレージ（EBS）。</li>
            <li>ネットワーキング：VPC、ロードバランサー、DNS、CDN。</li>
            <li>サーバーレス関数：イベント駆動型ロジックのためのLambda関数。</li>
            <li>APIゲートウェイ：APIの管理と保護のため。</li>
            <li>決定的に重要なのは、セキュリティと最小権限の原則です。現代のアプリケーションは、最小権限の原則に基づいて構築された堅牢なセキュリティアーキテクチャを必要とします。これは、アプリケーションの各コンポーネントがその機能を実行するために必要な最小限のリソースにのみアクセスできるように、詳細な役割と権限を定義することを意味します。セキュリティは後付けではなく、アプリケーションの設計とデプロイメントの基本的な側面です。」</li>
         </ul>
    </blockquote>
    <p>「アプリケーション」を単なるコンテナとして狭く定義することは、そのドメイン駆動型の範囲を無視することになり、制限的になります。より正確で有用な定義は、物理的な場所や種類に関係なく、ビジネス機能を提供するために必要なすべてのリソースを持つ自己完結型の垂直スライスとして、すべての密結合された論理リソースを境界付けられたコンテキストとして包含します。</p>

    <h2>アプリケーション中心のインフラストラクチャ：ドメイン駆動型アプローチ</h2>
    <p>この「アプリケーション」のより広範な定義は、アプリケーション中心のインフラストラクチャ設計につながります。このパラダイムは、個々のリソースを個別に管理することから、論理的なアプリケーション境界の周りにインフラストラクチャを編成することに焦点を移します。主な原則は次のとおりです。</p>
    <ul>
        <li><strong>アプリケーションスタック = 垂直スライス：</strong> 各アプリケーションは、インフラストラクチャとランタイムコンポーネントを含む、必要なすべてのリソースを含む自己完結型の「スタック」として定義されます。このスタックは、アプリケーションの環境の単一の信頼できる情報源となり、ドメイン駆動設計（DDD）の「境界付けられたコンテキスト」の概念を反映します。</li>
        <li><strong>共有モジュラーまたはサービスのためのプラットフォームスタック：</strong> 中央EKSクラスターのような共有インフラストラクチャコンポーネントは、別の「プラットフォームスタック」に配置されます。サービスとしてのネットワークを介した共有。アプリケーションスタックは、このプラットフォームスタックに依存し、関心事の明確な分離を作成し、再利用性を促進します。</li>
        <li><strong>物理性よりも論理的な結束：</strong> リソースは、物理的な場所やサービスタイプではなく、アプリケーションとの論理的な関係に基づいてグループ化されます。同じアプリケーションに属するS3バケット、DynamoDBテーブル、およびKubernetesデプロイメントはすべて、アプリケーションスタック内でまとまりのあるユニットとして管理されます。</li>
    </ul>

    <h3>利点：</h3>
    <ul>
        <li>一貫性の向上：すべてのアプリケーションリソースを単一のスタックで管理することで、構成のずれが減少し、一貫した環境が保証されます。</li>
        <li>管理性の向上：アプリケーションスタックは、デプロイメント、更新、ロールバックを簡素化し、アプリケーションのライフサイクル管理をより合理化します。</li>
        <li>明確なアプリケーション所有権：チームはアプリケーションスタック全体を所有および管理でき、自律性と説明責任を促進します。</li>
        <li>簡素化されたコスト配分：リソースコストは、専用スタックを通じて特定のアプリケーションに簡単に配分されます。</li>
        <li>クラウドネイティブ原則との整合性：疎結合で独立してデプロイ可能なアプリケーションユニットを促進します。</li>
        <li>セキュリティ体制の強化：アプリケーションスタックは、明確なセキュリティ境界を作成し、各アプリケーションの範囲内で詳細な権限管理を可能にすることにより、最小権限アクセス制御の実装を容易にします。</li>
    </ul>
    <p>このアプリケーション中心のアプローチは、ドメイン駆動設計（DDD）の哲学と深く共鳴します。DDDが境界付けられたコンテキストとドメインロジックの周りにソフトウェアを編成するのと同様に、アプリケーション中心のインフラストラクチャは、論理的なアプリケーションドメインの周りにクラウドリソースを編成します。この整合性は、明確さ、一貫性、およびインフラストラクチャ管理へのビジネス価値へのより強力な焦点をもたらします。</p>

    <h2>AWS CDK：インフラストラクチャとランタイム管理の統一</h2>
    <p>AWS Cloud Development Kit (CDK) は、アプリケーション中心のインフラストラクチャの強力なイネーブラーとして登場します。CDKは、従来のInfrastructure as Codeの複雑さを抽象化し、使い慣れたプログラミング言語を使用して、インフラストラクチャとランタイムオーケストレーションの両方を単一の統一されたコードベースで定義できるようにします。</p>
    <ul>
        <li><strong>抽象化によるInfrastructure-as-Code：</strong> CDKは、ベストプラクティスが組み込まれたAWSリソース（VPC、S3、RDSなど）を定義するための高レベルの構成要素を提供し、インフラストラクチャ定義を簡素化し、定型的な記述を削減します。</li>
        <li><strong>cdk8sによるランタイムオーケストレーション：</strong> CDKはcdk8sと統合されており、CDKコード内で直接Kubernetesマニフェストを定義できます。これにより、アプリケーションスタックの一部としてKubernetesリソース（Deployment、Service、Custom Resource）のシームレスな管理が可能になります。</li>
        <li><strong>統一されたツールとワークフロー：</strong> CDKは、インフラストラクチャからランタイムまで、アプリケーションスタック全体を管理するための単一のツールチェーンと一貫した開発者エクスペリエンスを提供します。</li>
        <li><strong>簡素化された依存関係管理：</strong> CDKは依存関係管理を簡素化し、同じスタック内でAWSリソースとKubernetesリソース間の依存関係を定義できるようにします。</li>
        <li><strong>Infrastructure as Secure Code：</strong> CDKは、Infrastructure as Codeだけでなく、Infrastructure as Secure Codeでもあります。CDKは、IAMロール、ポリシー、およびセキュリティグループを定義するための構成要素を提供し、セキュリティのベストプラクティスをインフラストラクチャ定義に直接埋め込むことができます。これは、最小権限を実装し、安全なアプリケーションデプロイメントを保証するために不可欠です。</li>
        <li><strong>詳細な権限管理：</strong> CDKにより、アプリケーションスタック内のリソースにきめ細かい権限を付与することが容易になります。各アプリケーションコンポーネントのアクセス要件に正確に一致するIAMロールとポリシーを定義できるため、過剰な権限付与のリスクが最小限に抑えられます。</li>
    </ul>
    <p>CDKを使用することで、チームは断片化されたツールやハイブリッドアプローチを超えて、アプリケーションの真に統一されたスタック定義を採用できます。</p>

    <h2>デプロイメントツールの進化</h2>
    <p>クラウドインフラストラクチャ管理の状況は、現代のアプリケーションの複雑さの増大と、より効率的で一貫したデプロイメント戦略の必要性によって、大幅な進化を遂げてきました。当初、組織は専門化されたツールの断片化されたエコシステムをナビゲートし、運用上のオーバーヘッドと不整合を引き起こしていました。以下は、クラウドデプロイメントツールの進化を3つの異なるフェーズでたどり、AWS Cloud Development Kit (CDK) に代表される統一スタックアプローチの出現で最高潮に達します。</p>

    <h3>フェーズ1：断片化されたツール – 専門化とサイロの時代</h3>
    <p>クラウド導入の初期には、組織はしばしば、それぞれがクラウド環境の特定の側面に対処する、ばらばらで専門化されたツールに依存していました。2つの顕著な例は、AWS CloudFormationとKubernetesであり、それぞれ異なる運用哲学から生まれました。</p>
    <ul>
        <li><strong>AWS CloudFormation：分離されたインフラストラクチャプロビジョニング：</strong> CloudFormationは、インフラストラクチャプロビジョニングにおける確実性と一貫性に焦点を当てた、エンジニアリング中心の世界から生まれました。宣言型テンプレートを通じて幅広いAWSリソースを定義およびデプロイすることに優れていました。ただし、Kubernetesリソースへのアプローチはしばしば限定的であり、動的に管理されるエンティティではなく静的なYAML定義として扱っていました。</li>
        <li><strong>Kubernetes：コンテナオーケストレーション、インフラストラクチャに依存しない：</strong> Kubernetesは、運用現場から生まれ、動的環境におけるアドホックな運用と緩和策を優先しました。コンテナオーケストレーションに革命をもたらし、基盤となるインフラストラクチャの複雑さを抽象化して、コンテナ化されたアプリケーションを大規模に管理しました。ただし、Kubernetesはネイティブ形式では、ストレージバケットやデータベースなど、クラスター外のクラウドリソースを直接プロビジョニングおよび管理する機能がありませんでした。</li>
    </ul>
    <h4>結果：ツールチェーンの無秩序な増加と運用上の摩擦</h4>
    <p>この断片化されたアプローチは、いくつかの課題を引き起こしました。</p>
    <ul>
        <li><strong>ツールチェーンの無秩序な増加：</strong> 組織は多様なツールセットを蓄積し、それぞれに専門知識が必要でした。この複雑さにより、トレーニングコストが増加し、全体的な管理が妨げられました。</li>
        <li><strong>構成のずれ：</strong> インフラストラクチャとアプリケーションの構成を別々のシステムで管理すると、必然的に構成のずれが生じました。あるシステムでの変更が他のシステムに自動的に反映されないため、再現やトラブルシューティングが困難な「スノーフレーク」環境が作成されました。</li>
        <li><strong>運用上のオーバーヘッド：</strong> 個別のツールチェーンを運用すると、運用上の複雑さが増しました。異なるシステム間でデプロイメント、更新、監視を調整するには、多大な手作業とカスタムスクリプトが必要であり、エラーや運用上のオーバーヘッドの可能性が高まりました。</li>
        <li><strong>限定的な全体像：</strong> 統合の欠如により、アプリケーションスタック全体の統一された全体像を把握することが困難でした。監視とトラブルシューティングには、多くの場合、さまざまなツールインターフェイス間を移動し、サイロ間でデータを関連付ける必要がありました。</li>
    </ul>

    <h3>フェーズ2：ハイブリッドアプローチ – 複雑さでギャップを埋める</h3>
    <p>断片化されたツールの限界を認識し、組織はインフラストラクチャとアプリケーション管理の間のギャップを埋めるためにハイブリッドアプローチを採用し始めました。一般的なパターンは、以下を組み合わせることでした。</p>
    <ul>
        <li><strong>インフラストラクチャ基盤のためのCloudFormation：</strong> CloudFormationは、仮想プライベートクラウド（VPC）、コンピューティングリソース、マネージドサービス、さらには基盤となるEKS（Elastic Kubernetes Service）クラスターを含む、基盤となるインフラストラクチャのプロビジョニングに引き続き使用されました。</li>
        <li><strong>アプリケーションデプロイメントのためのKubernetesネイティブツール：</strong> CloudFormationによってプロビジョニングされたKubernetesクラスター内で、組織はアプリケーションライフサイクル管理のためにKubernetesネイティブツールを採用しました。
            <ul>
                <li>Helm：Kubernetes内でアプリケーションをチャートとしてパッケージ化、テンプレート化、デプロイするため。</li>
                <li>GitOpsツール（Argo CD、Flux）：Gitを信頼できる情報源として使用し、Kubernetes内で継続的デリバリーと宣言的アプリケーション構成管理を実装するため。</li>
            </ul>
        </li>
    </ul>
    <h4>ハイブリッドアプローチの限界：</h4>
    <p>ハイブリッドアプローチは完全に断片化されたツールよりも改善をもたらしましたが、新たな複雑さを導入しました。</p>
    <ul>
        <li><strong>パラダイムの不整合（IaC vs. GitOps）：</strong> ハイブリッドモデルは、多くの場合、Infrastructure-as-Code（IaC）の原則とGitOpsプラクティスを並置しました。CloudFormationテンプレートは宣言的でインフラストラクチャ中心のアプローチを具現化しましたが、GitOpsはKubernetes内のアプリケーションデプロイメントに焦点を当てた別の宣言的モデルを導入しました。これらの異なる宣言的システムを管理および調整することは、抽象化の層と潜在的な混乱を追加しました。</li>
        <li><strong>複数システムの専門知識の継続的な必要性：</strong> 統合の取り組みにもかかわらず、チームは依然としてCloudFormationとKubernetesエコシステムの両方の専門知識を必要としていました。これにはより広範なスキルセットが必要であり、組織内の知識サイロにつながる可能性がありました。</li>
        <li><strong>複雑なロールバックと監査：</strong> 包括的なロールバックの実行や徹底的な監査の実施は、より複雑になりました。アプリケーションスタック全体をロールバックするには、CloudFormation（インフラストラクチャの変更用）とKubernetesツール（アプリケーションのデプロイメント用）の両方で調整されたロールバックが必要になる場合があり、多くの場合、カスタムスクリプトと手動オーケストレーションが必要でした。これらの異なるシステム間で変更を監査することは依然として課題でした。</li>
    </ul>

    <h3>フェーズ3：CDKによる統一スタック – インフラストラクチャとランタイムの収束</h3>
    <p>現在の進化は、インフラストラクチャとランタイム管理が単一のまとまりのあるコードベースに収束する、統一スタックアプローチを示しています。AWS Cloud Development Kit (CDK) はこのフェーズ3を例示しており、基盤となるインフラストラクチャからランタイムオーケストレーションまで、アプリケーションスタック全体を単一の開発者フレンドリーな環境内で定義および管理するための強力なフレームワークを提供します。</p>
    <h4>AWS CDK：インフラストラクチャとランタイム管理の統一</h4>
    <p>AWS CDKはAWS CloudFormationの上にある抽象化レイヤーとして機能しますが、開発エクスペリエンスを根本的に変えます。</p>
    <ul>
        <li><strong>プログラミング言語によるInfrastructure-as-Code：</strong> CDKにより、開発者はTypeScript、Python、Java、Goなどの使い慣れたプログラミング言語を使用してAWSインフラストラクチャを定義できます。これにより、冗長なJSON/YAMLテンプレートから脱却し、ループ、条件分岐、関数、オブジェクト指向の原則など、インフラストラクチャ定義のためのプログラミング構成要素の力を活用できます。</li>
        <li><strong>高レベルの抽象化（コンストラクト）：</strong> CDKは、ベストプラクティスが組み込まれた事前構築済みの再利用可能なコンポーネントであるコンストラクトの豊富なライブラリを提供します。これらのコンストラクトは、VPC、S3バケット、データベース、さらにはEKSクラスターなどの複雑なリソースの定義を簡素化し、定型的な記述を削減し、一貫性を促進します。</li>
        <li><strong>cdk8s統合によるランタイムオーケストレーション：</strong> CDKはcdk8s（Cloud Development Kit for Kubernetes）とシームレスに統合されており、開発者は同じプログラミング言語と抽象化を使用して、CDKコード内で直接Kubernetesマニフェストを定義できます。これにより、単一のスタック定義内でAWSクラウドリソースとKubernetesリソースの両方を統一的に管理できます。</li>
        <li><strong>統一されたツールとワークフロー：</strong> CDKは、アプリケーションスタック全体の開発、デプロイ、管理のための統一されたコマンドラインインターフェイス（CDK CLI）とワークフローを提供します。開発者は、単一のツールチェーンとプログラミング言語を使用して、インフラストラクチャプロビジョニングとアプリケーションランタイムオーケストレーションの両方を処理できます。</li>
    </ul>
    <h4>CDKによる統一スタックの利点：</h4>
    <ul>
        <li>運用の簡素化：単一の統一されたコードベースを管理することで、運用が簡素化されます。インフラストラクチャとアプリケーションの構成が一緒に管理されるため、デプロイメント、更新、ロールバックがより合理化され、アトミックになります。</li>
        <li>一貫性の向上とドリフトの削減：インフラストラクチャとランタイム構成の両方を同じコードベース内で定義することで、本質的に一貫性が促進され、構成ドリフトが最小限に抑えられます。インフラストラクチャとアプリケーションへの変更はバージョン管理され、一緒にデプロイされるため、よりまとまりのある予測可能な環境が保証されます。</li>
        <li>開発者エクスペリエンスと生産性の向上：使い慣れたプログラミング言語、高レベルのコンストラクト、および統一されたツールチェーンを使用することで、開発者エクスペリエンスが大幅に向上します。CDKにより、インフラストラクチャ定義がよりアクセスしやすく、楽しく、効率的になり、開発者の生産性が向上し、エラーが削減されます。</li>
        <li>堅牢な依存関係管理：CloudFormation上に構築されたCDKは、その堅牢な依存関係管理機能を継承します。開発者は、スタック内のすべてのリソース（AWSインフラストラクチャとKubernetesリソースの両方）間の依存関係を定義でき、適切な作成と更新の順序を保証します。</li>
        <li>合理化された監査とロールバック：統一スタックにより、監査とロールバックが簡素化されます。変更はCDKコードのバージョン管理で追跡され、明確な監査証跡が提供されます。ロールバックはスタックレベルで実行でき、インフラストラクチャとアプリケーション構成の両方を調整された方法で元に戻すことができます。</li>
        <li>アプリケーション中心のインフラストラクチャに向けて：CDKは、アプリケーション中心のインフラストラクチャ設計を容易にします。アプリケーションを、密結合されたすべてのリソース（インフラストラクチャとランタイムコンポーネント）を含む全体的なユニットとして定義することにより、組織はより優れたアプリケーション所有権、分離、および管理性を実現できます。</li>
    </ul>

    <p>（注：以下は特定の実装ノートまたはリンクのようです）</p>
    <p><a href="https://github.com/ondemandenv/odmd-eks/blob/5f67a7ec01f2effe4302c4a00a33adb0eedca0da/lib/simple-k8s-manifest.ts#L10" target="_blank">https://github.com/ondemandenv/odmd-eks/.../simple-k8s-manifest.ts#L10</a></p>
    <p>この単一のスタックは、EKSクラスター内外のすべてのリソースのライフサイクルと依存関係を管理し、必要なすべてのリソース（インフラストラクチャとランタイムコンポーネント）を含む自己完結型の「スタック」にします。このスタックは、アプリケーションの環境の単一の信頼できる情報源となり、ドメイン駆動設計（DDD）の「境界付けられたコンテキスト」の概念を反映します。</p>
    <p>AWS CloudFormationは、スタック内のすべてのリソース間の依存関係を維持し、トランザクション内で順序どおりにデプロイおよびロールバックされるようにします。</p>
    <p>これは実際のコードであり、次のようなパラメータ化によるわずかなコーディング抽象化が行われています。</p>
    <pre><code>//what branch I am on
const br = execSync('git rev-parse --abbrev-ref HEAD').toString().trim();
//configuration based on branch
const imgAndVer = StringParameter.valueForStringParameter(this, '/my-app/' + br );</code></pre>
    <p>これにより、異なるブランチ上の同一のコードが、複数の環境（ブランチ指定の構成値を持つ同一のロジック/機能マニフェスト）に対して生成およびデプロイされ、さらなる実験、発見、テスト、または本番環境での高い一貫性、ブランチによるコード比較、および単体テストが可能になり、GitOpsを凌駕します！</p>
    <p>上記は<a href="https://ondemandenv.dev" target="_blank">https://ondemandenv.dev</a>の根本的な哲学であり、もう1つの抽象化レイヤーをサポートしています。つまり、複数のアカウント間でVPCを接続し、各アカウントが動的な値/トークン解決を使用してプライベートサブネット経由でk8sマニフェストをデプロイできるようにします。</p>

     <!-- 必要に応じてここにさらにコンテンツを追加 -->

</main>

<footer>
    <p>&copy; 2024 ONDEMANDENV.dev. 無断複写・転載を禁じます。</p>
    <!-- 必要に応じてフッターリンクを追加 -->
</footer>

</body>
</html> 